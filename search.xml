<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Matplotlib</title>
      <link href="/2020/08/03/matplotlib/"/>
      <url>/2020/08/03/matplotlib/</url>
      
        <content type="html"><![CDATA[<p>matplotlib记录</p><a id="more"></a><h1><span id="ndarray对象">Ndarray对象</span></h1><ul><li>ndarray 对象是用于存放同类型元素的多维数组。</li><li>ndarray 中的每个元素在内存中都有相同存储大小的区域。</li></ul><h2><span id="创建数组函数">创建数组函数</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">numpy.array(object, dtype &#x3D; None, copy &#x3D; True, order &#x3D; None, subok &#x3D; False, ndmin &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>object</td><td>数组或嵌套的数列</td></tr><tr><td>dtype</td><td>数据元素的数据类型（可选）</td></tr><tr><td>copy</td><td>是否需要复制（可选）</td></tr><tr><td>order</td><td>创建数组的样式（可选）</td></tr><tr><td>ndmin</td><td>指定生成数组的最小维度（可选）</td></tr><tr><td><strong>实例</strong></td><td></td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as np a &#x3D; np.array([1,  2,  3,4,5], ndmin &#x3D;  2)  print (a)#[[1, 2, 3, 4, 5]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1><span id="numpy数据类型">Numpy数据类型</span></h1><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上</p><h2><span id="数组属性函数">数组属性函数</span></h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">af&#x3D;np.arange(24)print(af)# [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]af&#x3D;af.reshape(4,6)print(af)&quot;&quot;&quot;[[ 0  1  2  3  4  5] [ 6  7  8  9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]]&quot;&quot;&quot;print(af.ndim)#2print(af.shape)#(4, 6)print(af.size) #24print(af.dtype) #int32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="创建特殊数组">创建特殊数组</span></h1><p>ndarray 数组除了可以使用底层 ndarray 构造器来创建外，也可以通过以下几种方式来创建。</p><ol><li><strong>numpy.empty()</strong> 创建未初始化数组<pre class="line-numbers language-py" data-language="py"><code class="language-py">x &#x3D; np.empty([3,2], dtype &#x3D; int) print (x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><strong>numpy.zeros()</strong> 创建全0数组<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np# 默认为浮点数x &#x3D; np.zeros(5) print(x) # 设置类型为整数y &#x3D; np.zeros((5,), dtype &#x3D; np.int) print(y)# 自定义类型z &#x3D; np.zeros((2,2), dtype &#x3D; [(&#39;x&#39;, &#39;i4&#39;), (&#39;y&#39;, &#39;i4&#39;)])  print(z)&quot;&quot;&quot;[0. 0. 0. 0. 0.][0 0 0 0 0][[(0, 0) (0, 0)][(0, 0) (0, 0)]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>numpy.ones()</strong> 创建全1数组<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np# 默认为浮点数x &#x3D; np.ones(5) print(x)# 自定义类型x &#x3D; np.ones([2,2], dtype &#x3D; int)print(x)&quot;&quot;&quot;[1. 1. 1. 1. 1.][[1 1][1 1]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>np.random.randn()</strong> 创建服从 X~N(0,1) 的正态分布随机数组<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa&#x3D;np.random.randn(2,3)print(a)&quot;&quot;&quot;[[-0.3966213  -0.06741045 -0.40428291][-0.71045397  0.44448979 -0.63622491]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><strong>np.random.randint()</strong> 创建随机整数数组<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa&#x3D;np.random.randint(5,8,(3,3))&quot;&quot;&quot;[[5 7 6][5 5 5][5 6 5]]&quot;&quot;&quot;b&#x3D;np.random.random((3,3))&quot;&quot;&quot;[[0.14673684 0.97974036 0.18784698][0.99827519 0.77898821 0.84816327][0.20701223 0.44820941 0.54553687]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>**np.arange()**创建特定区间数组</li></ol></li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.arange(10)b &#x3D; np.arange(10, 20)c &#x3D; np.arange(10, 20, 2)&quot;&quot;&quot;[0 1 2 3 4 5 6 7 8 9]  [10 11 12 13 14 15 16 17 18 19]   [10 12 14 16 18] &quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li><strong>np.eye()</strong> 创建对角矩阵数组</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.eye(5)&quot;&quot;&quot;[[1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="从已有数组创建数组">从已有数组创建数组</span></h1><ol><li><strong>np.asarray()</strong> 创建数组<br><code>array</code>和<code>asarray</code>都可以将结构数据转化为ndarray，但是主要区别就是当数据源是ndarray时，<code>array</code>仍然会copy出一个副本，占用新的内存，但<code>asarray</code>不会。<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np  #example 2:  arr1&#x3D;np.ones((3,3))  arr2&#x3D;np.array(arr1)  arr3&#x3D;np.asarray(arr1)  arr1[1]&#x3D;2  print &#39;arr1:\n&#39;,arr1  print &#39;arr2:\n&#39;,arr2  print &#39;arr3:\n&#39;,arr3&quot;&quot;&quot;arr1:  [[ 1.  1.  1.]  [ 2.  2.  2.]  [ 1.  1.  1.]]  arr2:  [[ 1.  1.  1.]  [ 1.  1.  1.]  [ 1.  1.  1.]]  arr3:  [[ 1.  1.  1.]  [ 2.  2.  2.]  [ 1.  1.  1.]]  &quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>numpy.fromiter()</strong> 从迭代器创建数组</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np list&#x3D;range(5)it&#x3D;iter(list)x&#x3D;np.fromiter(it, dtype&#x3D;float)print(x) #[0. 1. 2. 3. 4.]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="从数值范围创建数组">从数值范围创建数组</span></h1><p><code>numpy.arange(start, stop, step, dtype)</code></p><h2><span id="生成等差序列">生成等差序列</span></h2><p><code>numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code><br>|名称|描述|<br>|–|–|<br>|num|生成等步长的样本容量<br>|endpoint|该值为 true 时，数列中中包含stop值，反之不包含，默认是True</p><h2><span id="生成等比序列">生成等比序列</span></h2><p><code>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code><br>|名称|描述|<br>|–|–|<br>|start|序列的起始值为：base ** start<br>|stop|序列的终止值为：base ** stop<br>|num|生成的样本容量<br>|base|对数 log 的底数</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.logspace(0,9,10,base&#x3D;2)print (a)# [  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="切片和索引">切片和索引</span></h1><p>一维数组中的切片方法</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.arange(10)  #[0 1 2 3 4 5 6 7 8 9]b &#x3D; a[2:7:2]   # 从索引 2 开始到索引 7 停止，间隔为 2 print(b) #[2 4 6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>二维数组中的切片方法</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa&#x3D;np.arange(0,12)a.shape&#x3D;(3,4)print(a)print(a[0:2,1:3])&quot;&quot;&quot;[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]][[1 2] [5 6]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="高级索引">高级索引</span></h1><p>以下实例获取数组中(0,0)，(1,1)和(2,0)位置处的元素。</p><h2><span id="整数数组索引">整数数组索引</span></h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">mport numpy as np x &#x3D; np.array([[1,  2],  [3,  4],  [5,  6]]) y &#x3D; x[[0,1,2],  [0,1,0]]  print (y)&quot;&quot;&quot;[1  4  5]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="布尔索引">布尔索引</span></h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np x &#x3D; np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  11]])  print (&#39;我们的数组是：&#39;)print (x)print (&#39;\n&#39;)# 现在我们会打印出大于 5 的元素  print  (&#39;大于 5 的元素是：&#39;)print (x[x &gt;  5])&quot;&quot;&quot;我们的数组是：[[ 0  1  2] [ 3  4  5] [ 6  7  8] [ 9 10 11]]大于 5 的元素是：[ 6  7  8  9 10 11]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="broadcast广播">Broadcast广播</span></h1><ul><li>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np a &#x3D; np.array([[ 0, 0, 0],           [10,10,10],           [20,20,20],           [30,30,30]])b &#x3D; np.array([1,2,3])print(a + b)&quot;&quot;&quot;[[ 1  2  3] [11 12 13] [21 22 23] [31 32 33]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>np.tile()</code>函数扩展数组</li><li><code>np.tile()</code>函数可以理解为对矩阵的横纵向复制<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npx&#x3D;np.ones((3,4))y&#x3D;np.tile(1,(3,4))strx&#x3D;&quot;x&quot;stry&#x3D;&quot;y&quot;print(strx.center(40,&quot;-&quot;))print(x)print(stry.center(40,&quot;-&quot;))print(y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="迭代数组">迭代数组</span></h1>NumPy 迭代器对象<code> numpy.nditer()</code>可以完成对数组元素的逐个访问</li><li><code>for x in np.nditer(a, order=&#39;F&#39;):</code>Fortran order，即是列序优先；</li><li><code>for x in np.nditer(a.T, order=&#39;C&#39;):</code>C order，即是行序优先</li><li>nditer 对象有另一个可选参数 <code>op_flags</code>， 可以选择<code>read-write</code> 或者 <code>write-only</code> 的模式，否则不能随意修改遍历值<pre class="line-numbers language-py" data-language="py"><code class="language-py">a &#x3D; np.arange(1,13).reshape(4,3)print(&quot;原始数组：&quot;)print(a)print(&quot;使用For循环输出：&quot;)for i in range(0,4):  for j in range(0,3):      print(a[i][j],end&#x3D;&#39;,&#39;)print(&quot;\n使用迭代器输出:&quot;)for x in np.nditer(a):  print(x,end&#x3D;&#39;,&#39;)print(&quot;\n修改数组元素：&quot;)for x in np.nditer(a,op_flags&#x3D;[&quot;readwrite&quot;]):  x&#x3D;x*2  print(x,end&#x3D;&#39;,&#39;)&quot;&quot;&quot;原始数组：[[ 1  2  3][ 4  5  6][ 7  8  9][10 11 12]]使用For循环输出：1,2,3,4,5,6,7,8,9,10,11,12,使用迭代器输出:1,2,3,4,5,6,7,8,9,10,11,12,修改数组元素：2,4,6,8,10,12,14,16,18,20,22,24,&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="数组操作函数">数组操作函数</span></h1><h2><span id="修改数组形状">修改数组形状</span></h2><code>np.reshsape(row,col)</code>函数，修改函数形状<br><code>np.flat()</code>函数，返回数组迭代器<br><code>np.flatten()</code>函数，返回展开的数组对象，不会修改原数组<br><code>numpy.ravel(a, order=&#39;C&#39;)</code>函数，返回数组视图，修改会影响原数组</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">a &#x3D; np.arange(1,13).reshape(3,4)print(&quot;原始数组：&quot;)print(a)print(&quot;使用np.flat迭代器：&quot;)for x in a.flat:    print(x,end&#x3D;&#39;,&#39;)b &#x3D; a.flatten()b[0]&#x3D;0print(&quot;\n输出flatten展开并且修改后的数组：&quot;)print(b)c &#x3D; a.ravel()c[0]&#x3D;10print(&quot;输出ravel展开并修改的数组：&quot;)print(c)print(&quot;原始数组:&quot;)print(a)&quot;&quot;&quot;原始数组：[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]使用np.flat迭代器：1,2,3,4,5,6,7,8,9,10,11,12,输出flatten展开并且修改后的数组：[ 0  2  3  4  5  6  7  8  9 10 11 12]输出ravel展开并修改的数组：[10  2  3  4  5  6  7  8  9 10 11 12]原始数组:[[10  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="反转数组">反转数组</span></h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>np.transpose()</code></td><td>对数组进行转置</td></tr><tr><td><code>np.T</code></td><td>对数组进行转置</td></tr></tbody></table><h2><span id="修改数组维度">修改数组维度</span></h2><ol><li><code>np.broadcast(x,y)</code>函数对y广播x，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。<code>np.broadcast(x,y)</code>返回的对象有两个属性<code>iters</code>和<code>shape</code><br>&lt;!–hexoPostRenderEscape:<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np</code></pre></li></ol><p>x &#x3D; np.array([[1], [2], [3]])<br>y &#x3D; np.array([4, 5, 6])  </p><h1><span id="对-y-广播-x">对 y 广播 x</span></h1><p>b &#x3D; np.broadcast(x,y)  </p><h1><span id="它拥有-iterator-属性基于自身组件的迭代器元组">它拥有 iterator 属性，基于自身组件的迭代器元组</span></h1><p>print (&#39;对 y 广播 x：&#39;)<br>r,c &#x3D; b.iters<br>print (next(r), next(c))<br>print (next(r), next(c))<br>print (next(r), next(c))<br>print (next(r), next(c))<br>print (next(r), next(c))<br>print (next(r), next(c))<br>print (&#39;广播对象的形状：&#39;)<br>print (b.shape)<br>print (&#39;\n&#39;)</p><h1><span id="手动使用-broadcast-将-x-与-y-相加">手动使用 broadcast 将 x 与 y 相加</span></h1><p>b &#x3D; np.broadcast(x,y)<br>c &#x3D; np.empty(b.shape)</p><p>print (&#39;手动使用 broadcast 将 x 与 y 相加：&#39;)<br>print (c.shape)<br>print (&#39;\n&#39;)<br>c.flat &#x3D; [u + v for (u,v) in b]</p><p>print (&#39;调用 flat 函数：&#39;)<br>print (c)<br>print (&#39;\n&#39;)</p><h1><span id="获得了和-numpy-内建的广播支持相同的结果">获得了和 NumPy 内建的广播支持相同的结果</span></h1><p>print (&#39;x 与 y 的和：&#39;)<br>print (x + y)</p><p>&quot;&quot;&quot;<br>对 y 广播 x：<br>1 4<br>1 5<br>1 6<br>2 4<br>2 5<br>2 6<br>广播对象的形状：<br>(3, 3)</p><p>手动使用 broadcast 将 x 与 y 相加：<br>(3, 3)</p><p>调用 flat 函数：<br>[[5. 6. 7.]<br> [6. 7. 8.]<br> [7. 8. 9.]]</p><p>x 与 y 的和：<br>[[5 6 7]<br> [6 7 8]<br> [7 8 9]]<br>&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span>:hexoPostRenderEscape–&gt;<br>2. <code>numpy.broadcast_to()</code> 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.arange(4).reshape(1,4)print (&#39;原数组：&#39;)print (a)print (&#39;\n&#39;)print (&#39;调用 broadcast_to 函数之后：&#39;)print (np.broadcast_to(a,(4,4)))&quot;&quot;&quot;原数组：[[0 1 2 3]]调用 broadcast_to 函数之后：[[0 1 2 3] [0 1 2 3] [0 1 2 3] [0 1 2 3]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><code>numpy.expand_dims(arr, axis)</code>通过在指定位置插入新的轴来扩展数组形状</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npx &#x3D; np.array(([1,2],[3,4]))print (&#39;数组 x：&#39;)print (x)print (&#39;在位置 0 插入轴之后的数组 y：&#39;)y &#x3D; np.expand_dims(x, axis &#x3D; 0)print (y)print (&quot;x形状:&quot;,x.shape, &quot;y形状：&quot;,y.shape)print(&quot;x.ndim:&quot;,x.ndim,&quot;y.ndim:&quot;,y.ndim)print (&#39;在位置 1 插入轴之后的数组 y：&#39;)y &#x3D; np.expand_dims(x, axis &#x3D; 1)print (y)print (&quot;x形状:&quot;,x.shape, &quot;y形状：&quot;,y.shape)print(&quot;x.ndim:&quot;,x.ndim,&quot;y.ndim:&quot;,y.ndim)print (&#39;在位置 2 插入轴之后的数组 y：&#39;)y &#x3D; np.expand_dims(x, axis &#x3D; 2)print (y)print (&quot;x形状:&quot;,x.shape, &quot;y形状：&quot;,y.shape)print(&quot;x.ndim:&quot;,x.ndim,&quot;y.ndim:&quot;,y.ndim)&quot;&quot;&quot;数组 x：[[1 2] [3 4]]在位置 0 插入轴之后的数组 y：[[[1 2]  [3 4]]]x形状: (2, 2) y形状： (1, 2, 2)x.ndim: 2 y.ndim: 3在位置 1 插入轴之后的数组 y：[[[1 2]] [[3 4]]]x形状: (2, 2) y形状： (2, 1, 2)x.ndim: 2 y.ndim: 3在位置 2 插入轴之后的数组 y：[[[1]  [2]] [[3]  [4]]]x形状: (2, 2) y形状： (2, 2, 1)x.ndim: 2 y.ndim: 3&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><code>numpy.squeeze(arr, axis)</code>函数从给定数组的形状中删除一维的条目</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">x&#x3D;np.array([1,2,3,4])y&#x3D;np.expand_dims(x,1)print(&quot;在位置1插入新轴：&quot;)print(y)z&#x3D;np.squeeze(y,1)print(&quot;删除位置1的轴：&quot;)print(z)&quot;&quot;&quot;在位置1插入新轴：[[1] [2] [3] [4]]删除位置1的轴：[1 2 3 4]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="连接数组">连接数组</span></h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>numpy.concatenate()</code></td><td>沿现有轴连接数组</td></tr><tr><td><code>stack</code></td><td>沿着新的轴加入一系列数组</td></tr></tbody></table><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.array([[1,2],[3,4]])print (&#39;第一个数组：&#39;)print (a)b &#x3D; np.array([[5,6],[7,8]])print (&#39;第二个数组：&#39;)print (b)print (&#39;沿轴 0 连接两个数组：&#39;)print (np.concatenate((a,b)))&quot;&quot;&quot;[[1 2] [3 4] [5 6] [7 8]]&quot;&quot;&quot;print (&#39;沿轴 1 连接两个数组：&#39;)print (np.concatenate((a,b),axis &#x3D; 1))&quot;&quot;&quot;[[1 2 5 6] [3 4 7 8]]&quot;&quot;&quot;print (&#39;沿轴 0 堆叠两个数组：&#39;)print (np.stack((a,b),0))&quot;&quot;&quot;[[[1 2]  [3 4]] [[5 6]  [7 8]]]&quot;&quot;&quot;print (&#39;沿轴 1 堆叠两个数组：&#39;)print (np.stack((a,b),1))&quot;&quot;&quot;[[[1 2]  [5 6]] [[3 4]  [7 8]]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="分割数组">分割数组</span></h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>numpy.split(ary, indices_or_sections, axis)</code></td><td>将一个数组分割为多个子数组</td></tr><tr><td><code>numpy.hsplit()</code></td><td>水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组</td></tr><tr><td><code>numpy.vsplit()</code></td><td>沿着垂直轴分割，其分割方式与hsplit用法相同。</td></tr></tbody></table><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.arange(9)print (&#39;第一个数组：&#39;)print (a)&quot;&quot;&quot;第一个数组：[0 1 2 3 4 5 6 7 8]&quot;&quot;&quot;print (&#39;将数组分为三个大小相等的子数组：&#39;)b &#x3D; np.split(a,3)print (b)&quot;&quot;&quot;将数组分为三个大小相等的子数组：[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]&quot;&quot;&quot;print (&#39;将数组在一维数组中表明的位置分割：&#39;)b &#x3D; np.split(a,[4,7])print (b)&quot;&quot;&quot;将数组在一维数组中表明的位置分割：[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-py" data-language="py"><code class="language-py">harr &#x3D; np.floor(10 * np.random.random((2, 6)))print (&#39;原array：&#39;)print(harr)print (&#39;拆分后：&#39;)print(np.hsplit(harr, 3))&quot;&quot;&quot;原array：[[8. 9. 6. 8. 7. 5.] [7. 6. 7. 3. 6. 7.]]拆分后：[array([[8., 9.],       [7., 6.]]), array([[6., 8.],       [7., 3.]]), array([[7., 5.],       [6., 7.]])]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="数组元素的添加与删除">数组元素的添加与删除</span></h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>numpy.resize(arr, shape)</code></td><td>函数返回指定大小的新数组</td></tr><tr><td><code>numpy.append(arr, values, axis=None)</code></td><td>追加操作会分配整个数组，并把原来的数组复制到新数组中,当axis无定义时，是横向加成，返回总是为一维数组</td></tr><tr><td><code>numpy.vsplit()</code></td><td>沿着垂直轴分割，其分割方式与hsplit用法相同。</td></tr></tbody></table><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.array([[1,2,3],[4,5,6]])print (&#39;第一个数组：&#39;)print (a)print (&#39;\n&#39;)&quot;&quot;&quot;第一个数组：[[1 2 3] [4 5 6]]&quot;&quot;&quot;print (&#39;第一个数组的形状：&#39;)print (a.shape)print (&#39;\n&#39;)b &#x3D; np.resize(a, (3,2))&quot;&quot;&quot;第一个数组的形状：(2, 3)&quot;&quot;&quot;print (&#39;第二个数组：&#39;)print (b)print (&#39;\n&#39;) &quot;&quot;&quot; 第二个数组：[[1 2] [3 4] [5 6]] &quot;&quot;&quot;print (&#39;第二个数组的形状：&#39;)print (b.shape)print (&#39;\n&#39;)# 要注意 a 的第一行在 b 中重复出现，因为尺寸变大了 &quot;&quot;&quot; 第二个数组的形状：(3, 2) &quot;&quot;&quot;print (&#39;修改第二个数组的大小：&#39;)b &#x3D; np.resize(a,(3,3))print (b)&quot;&quot;&quot;修改第二个数组的大小：[[1 2 3] [4 5 6] [1 2 3]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.array([[1,2,3],[4,5,6]])print (&#39;第一个数组：&#39;)print (a)print (&#39;\n&#39;) &quot;&quot;&quot; 第一个数组：[[1 2 3] [4 5 6]] &quot;&quot;&quot;print (&#39;向数组添加元素：&#39;)print (np.append(a, [7,8,9]))print (&#39;\n&#39;) &quot;&quot;&quot; 向数组添加元素：[1 2 3 4 5 6 7 8 9] &quot;&quot;&quot;print (&#39;沿轴 0 添加元素：&#39;)print (np.append(a, [[7,8,9]],axis &#x3D; 0))print (&#39;\n&#39;) &quot;&quot;&quot; 沿轴 0 添加元素：[[1 2 3] [4 5 6] [7 8 9]] &quot;&quot;&quot;print (&#39;沿轴 1 添加元素：&#39;)print (np.append(a, [[5,5,5],[7,8,9]],axis &#x3D; 1))&quot;&quot;&quot;沿轴 1 添加元素：[[1 2 3 5 5 5] [4 5 6 7 8 9]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.array([[1,2],[3,4],[5,6]])print (&#39;第一个数组：&#39;)print (a)print (&#39;\n&#39;)&quot;&quot;&quot;第一个数组：[[1 2] [3 4] [5 6]]&quot;&quot;&quot;print (&#39;未传递 Axis 参数。 在插入之前输入数组会被展开。&#39;)print (np.insert(a,3,[11,12]))print (&#39;\n&#39;)print (&#39;传递了 Axis 参数。 会广播值数组来配输入数组。&#39;) &quot;&quot;&quot; 未传递 Axis 参数。 在插入之前输入数组会被展开。[ 1  2  3 11 12  4  5  6] &quot;&quot;&quot;print (&#39;沿轴 0 广播：&#39;)print (np.insert(a,1,[11],axis &#x3D; 0))print (&#39;\n&#39;) &quot;&quot;&quot; 传递了 Axis 参数。 会广播值数组来配输入数组。沿轴 0 广播：[[ 1  2] [11 11] [ 3  4] [ 5  6]] &quot;&quot;&quot;print (&#39;沿轴 1 广播：&#39;)print (np.insert(a,1,11,axis &#x3D; 1))&quot;&quot;&quot;沿轴 1 广播：[[ 1 11  2] [ 3 11  4] [ 5 11  6]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.arange(12).reshape(3,4)print (&#39;第一个数组：&#39;)print (a)print (&#39;\n&#39;) &quot;&quot;&quot; 第一个数组：[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]] &quot;&quot;&quot;print (&#39;未传递 Axis 参数。 在插入之前输入数组会被展开。&#39;)print (np.delete(a,5))print (&#39;\n&#39;) &quot;&quot;&quot; 未传递 Axis 参数。 在插入之前输入数组会被展开。[ 0  1  2  3  4  6  7  8  9 10 11] &quot;&quot;&quot;print (&#39;删除第二列：&#39;)print (np.delete(a,1,axis &#x3D; 1))print (&#39;\n&#39;) &quot;&quot;&quot; 删除第二列：[[ 0  2  3] [ 4  6  7] [ 8 10 11]] &quot;&quot;&quot;print (&#39;包含从数组中删除的替代值的切片：&#39;)a &#x3D; np.array([1,2,3,4,5,6,7,8,9,10])print (np.delete(a, np.s_[::2]))&quot;&quot;&quot;包含从数组中删除的替代值的切片：[ 2  4  6  8 10]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="统计函数">统计函数</span></h1><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>numpy.amin() </code></td><td>计算数组中的元素沿指定轴的最小值</td></tr><tr><td><code>numpy.amax() </code></td><td>计算数组中的元素沿指定轴的最大值</td></tr><tr><td><code>numpy.ptp()</code></td><td>计算数组指定轴最大值与最小值之差</td></tr><tr><td><code>numpy.percentile()</code></td><td>统计百分位对应的值</td></tr><tr><td><code>numpy.median()</code></td><td>计算中值</td></tr><tr><td><code>numpy.mean()</code></td><td>沿某一轴计算均值</td></tr><tr><td><code>numpy.average()</code></td><td>计算加权平均值</td></tr><tr><td><code>np.std()</code></td><td>标准差</td></tr><tr><td><code>np.var()</code></td><td>方差</td></tr></tbody></table><ol><li>最大值最小值统计函数<br>&lt;!–hexoPostRenderEscape:<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np </code></pre></li></ol><p>a &#x3D; np.array([[3,7,5],[8,4,3],[2,4,9]])<br>print (&#39;我们的数组是：&#39;)<br>print (a)<br>&quot;&quot;&quot;<br>我们的数组是：<br>[[3 7 5]<br> [8 4 3]<br> [2 4 9]]<br>&quot;&quot;&quot;<br>print (&#39;\n&#39;)<br>print (&#39;调用 amin(a,0) 函数：&#39;)<br>print (np.amin(a,0))<br>print (&#39;\n&#39;)<br>&quot;&quot;&quot;<br>调用 amin(a,0) 函数：<br>[2 4 3]<br>&quot;&quot;&quot;<br>print (&#39;再次调用 amin(a,1) 函数：&#39;)<br>print (np.amin(a,1))<br>print (&#39;\n&#39;)<br>&quot;&quot;&quot;<br>再次调用 amin(a,1) 函数：<br>[3 3 2]<br>&quot;&quot;&quot;<br>print (&#39;调用 amax(a) 函数：&#39;)<br>print (np.amax(a))<br>print (&#39;\n&#39;)<br>&quot;&quot;&quot;<br>调用 amax(a) 函数：<br>9<br>&quot;&quot;&quot;<br>print (&#39;再次调用 amax(a,0) 函数：&#39;)<br>print (np.amax(a, axis &#x3D;  0))<br>&quot;&quot;&quot;<br>再次调用 amax(a,0) 函数：<br>[8 7 9]<br>&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span>:hexoPostRenderEscape–&gt;<br>2. 最大值与最小值之差函数</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np a &#x3D; np.array([[3,7,5],[8,4,3],[2,4,9]])  print (&#39;我们的数组是：&#39;)print (a)&quot;&quot;&quot;我们的数组是：[[3 7 5] [8 4 3] [2 4 9]]&quot;&quot;&quot;print (&#39;调用 ptp() 函数：&#39;)print (np.ptp(a))&quot;&quot;&quot;调用 ptp() 函数：7&quot;&quot;&quot;print (&#39;沿轴 1 调用 ptp() 函数：&#39;)print (np.ptp(a, axis &#x3D;  1))&quot;&quot;&quot;沿轴 1 调用 ptp() 函数：[4 5 7]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><code>numpy.percentile(a, p, axis)</code>第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np a &#x3D; np.array([[10, 7, 4], [3, 2, 1]])print (&#39;我们的数组是：&#39;)print (a) &quot;&quot;&quot; 我们的数组是：[[10  7  4] [ 3  2  1]] &quot;&quot;&quot;print (&#39;调用 percentile() 函数：&#39;)# 50% 的分位数，就是 a 里排序之后的中位数print (np.percentile(a, 50)) &quot;&quot;&quot;调用 percentile() 函数：3.5&quot;&quot;&quot;# axis 为 0，在纵列上求print (np.percentile(a, 50, axis&#x3D;0)) &quot;&quot;&quot;[6.5 4.5 2.5]&quot;&quot;&quot;# axis 为 1，在横行上求print (np.percentile(a, 50, axis&#x3D;1)) &quot;&quot;&quot;[7. 2.]&quot;&quot;&quot;# 保持维度不变print (np.percentile(a, 50, axis&#x3D;1, keepdims&#x3D;True))&quot;&quot;&quot;[[7.] [2.]]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。例子：<code>加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1)</code><br>&lt;!–hexoPostRenderEscape:<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np </code></pre></li></ol><p>a &#x3D; np.array([1,2,3,4])<br>print (&#39;我们的数组是：&#39;)<br>print (a)<br>&quot;&quot;&quot;<br>我们的数组是：<br>[1 2 3 4]<br>&quot;&quot;&quot;<br>print (&#39;调用 average() 函数：&#39;)<br>print (np.average(a))<br>&quot;&quot;&quot;<br>调用 average() 函数：<br>2.5<br>&quot;&quot;&quot;</p><h1><span id="不指定权重时相当于-mean-函数">不指定权重时相当于 mean 函数</span></h1><p>wts &#x3D; np.array([4,3,2,1])<br>print (&#39;再次调用 average() 函数：&#39;)<br>print (np.average(a,weights &#x3D; wts))<br>&quot;&quot;&quot;<br>再次调用 average() 函数：<br>2.0<br>&quot;&quot;&quot;</p><h1><span id="如果-returned-参数设为-true则返回权重的和">如果 returned 参数设为 true，则返回权重的和</span></h1><p>print (&#39;权重的和：&#39;)<br>print (np.average([1,2,3,  4],weights &#x3D;  [4,3,2,1], returned &#x3D;  True))<br>&quot;&quot;&quot;<br>权重的和：<br>(2.0, 10.0)<br>&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span>:hexoPostRenderEscape–&gt;<br>对特定轴进行加权</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np a &#x3D; np.arange(6).reshape(3,2)  print (&#39;我们的数组是：&#39;)print (a)&quot;&quot;&quot;我们的数组是：[[0 1] [2 3] [4 5]]&quot;&quot;&quot;print (&#39;修改后的数组：&#39;)wt &#x3D; np.array([3,5])  print (np.average(a, axis &#x3D;  1, weights &#x3D; wt))&quot;&quot;&quot;修改后的数组：[0.625 2.625 4.625]&quot;&quot;&quot;print (&#39;修改后的数组：&#39;)print (np.average(a, axis &#x3D;  1, weights &#x3D; wt, returned &#x3D;  True))&quot;&quot;&quot;修改后的数组：(array([0.625, 2.625, 4.625]), array([8., 8., 8.]))&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>方差与标准差计算</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np print (np.std([1,2,3,4]))print (np.var([1,2,3,4]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="数学函数">数学函数</span></h1><h1><span id="算术函数">算术函数</span></h1><h1><span id="字符串函数">字符串函数</span></h1><h1><span id="排序和条件筛选函数">排序和条件筛选函数</span></h1><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>numpy.sort()</code></td><td>对数组进行排序</td></tr><tr><td><code>numpy.lexsort()</code></td><td>对多个序列进行排序</td></tr><tr><td><code>numpy.argmax() </code></td><td>返回最大值的索引</td></tr><tr><td><code>numpy.nonzero()</code></td><td>返回数组非零元素的索引</td></tr><tr><td><code>numpy.where()</code></td><td>返回满足指定条件的索引</td></tr><tr><td><code>numpy.extract()</code></td><td>按照指定条件抽取元素</td></tr></tbody></table><ol><li><code>numpy.sort(a, axis, kind, order)</code><br>a: 要排序的数组<br>axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序<br>kind: 默认为’quicksort’（快速排序）<br>order: 如果数组包含字段，则是要排序的字段</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np  a &#x3D; np.array([[3,7],[9,1]])  print (&#39;我们的数组是：&#39;)print (a)&quot;&quot;&quot;我们的数组是：[[3 7] [9 1]]&quot;&quot;&quot;print (&#39;调用 sort() 函数：&#39;)print (np.sort(a))&quot;&quot;&quot;调用 sort() 函数：[[3 7] [1 9]]&quot;&quot;&quot;print (&#39;按列排序：&#39;)print (np.sort(a, axis &#x3D;  0))&quot;&quot;&quot;按列排序：[[3 1] [9 7]]&quot;&quot;&quot;# 在 sort 函数中排序字段 dt &#x3D; np.dtype([(&#39;name&#39;,  &#39;S10&#39;),(&#39;age&#39;,  int)]) a &#x3D; np.array([(&quot;raju&quot;,21),(&quot;anil&quot;,25),(&quot;ravi&quot;,  17),  (&quot;amar&quot;,27)], dtype &#x3D; dt)  print (&#39;我们的数组是：&#39;)print (a)&quot;&quot;&quot;我们的数组是：[(b&#39;raju&#39;, 21) (b&#39;anil&#39;, 25) (b&#39;ravi&#39;, 17) (b&#39;amar&#39;, 27)]&quot;&quot;&quot;print (&#39;按 name 排序：&#39;)print (np.sort(a, order &#x3D;  &#39;name&#39;))&quot;&quot;&quot;按 name 排序：[(b&#39;amar&#39;, 27) (b&#39;anil&#39;, 25) (b&#39;raju&#39;, 21) (b&#39;ravi&#39;, 17)]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>numpy.lexsort()</code> 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。<br>&lt;!–hexoPostRenderEscape:<pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np</code></pre></li></ol><h1><span id="录入了四位同学的成绩按照总分排序总分相同时语文高的优先">录入了四位同学的成绩，按照总分排序，总分相同时语文高的优先</span></h1><p>math    &#x3D; (10, 20, 50, 10)<br>chinese &#x3D; (30, 50, 40, 60)<br>total   &#x3D; (40, 70, 90, 70)</p><h1><span id="将优先级高的项放在后面">将优先级高的项放在后面</span></h1><p>ind &#x3D; np.lexsort((math, chinese, total))</p><p>for i in ind:<br>    print(total[i],chinese[i],math[i])<br>&quot;&quot;&quot;<br>40 30 10<br>70 50 20<br>70 60 10<br>90 40 50<br>&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span>:hexoPostRenderEscape–&gt;<br>3. <code>numpy.argmax() </code> 函数沿某一轴寻找最大值的索引</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npa &#x3D; np.array([3,1,5,6,8,2])print(np.argmax(a,0))&quot;&quot;&quot;4&quot;&quot;&quot;b &#x3D; np.random.randint(1,10,12).reshape(3,4)print(b)&quot;&quot;&quot;[[7 7 8 3] [5 9 6 3] [3 9 5 3]]&quot;&quot;&quot;print(np.argmax(b,0))&quot;&quot;&quot;[0 1 0 0]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><code>numpy.nonzero() </code>函数返回输入数组中非零元素的索引</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np a &#x3D; np.array([[30,40,0],[0,20,10],[50,0,60]])  print (&#39;我们的数组是：&#39;)print (a)print (&#39;\n&#39;)print (&#39;调用 nonzero() 函数：&#39;)print (np.nonzero (a))&quot;&quot;&quot;我们的数组是：[[30 40  0] [ 0 20 10] [50  0 60]]调用 nonzero() 函数：(array([0, 0, 1, 1, 2, 2]), array([0, 1, 1, 2, 0, 2]))&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><code>numpy.extract() </code>函数根据某个条件从数组中抽取元素，返回满条件的元素。</li></ol><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np x &#x3D; np.arange(9.).reshape(3,  3)  print (&#39;我们的数组是：&#39;)print (x)&quot;&quot;&quot;我们的数组是：[[0. 1. 2.] [3. 4. 5.] [6. 7. 8.]]&quot;&quot;&quot;# 定义条件, 选择偶数元素condition &#x3D; np.mod(x,2)  &#x3D;&#x3D;  0  print (&#39;按元素的条件值：&#39;)print (condition)&quot;&quot;&quot;按元素的条件值：[[ True False  True] [False  True False] [ True False  True]]&quot;&quot;&quot;print (&#39;使用条件提取元素：&#39;)print (np.extract(condition, x))&quot;&quot;&quot;使用条件提取元素：[0. 2. 4. 6. 8.]&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="矩阵">矩阵</span></h1><h1><span id="线性代数">线性代数</span></h1><h1><span id="numpy-io">Numpy IO</span></h1><h2><span id="npy文件">npy文件</span></h2><p><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code>函数将数组保存到以 .npy 为扩展名的文件中.</p><ul><li><strong>file</strong> ：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。<ul><li><strong>arr</strong>: 要保存的数组</li><li><strong>allow_pickle</strong>: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。</li></ul></li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np a &#x3D; np.array([1,2,3,4,5]) # 保存到 outfile.npy 文件上np.save(&#39;outfile.npy&#39;,a) # 保存到 outfile2.npy 文件上，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上np.save(&#39;outfile2&#39;,a)b &#x3D; np.load(&#39;outfile.npy&#39;)  print (b)# [1 2 3 4 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="npz文件">npz文件</span></h2><p><code>numpy.savez(file, *args, **kwds)</code>函数将多个数组保存到以 npz 为扩展名的文件中</p><ul><li><strong>file</strong>：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名npz，该扩展名会被自动加上。</li><li><strong>args</strong>: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0, arr_1, </li><li><strong>kwds</strong>: 要保存的数组使用关键字名称。</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as np a &#x3D; np.array([[1,2,3],[4,5,6]])b &#x3D; np.arange(0, 1.0, 0.1)c &#x3D; np.sin(b)# c 使用了关键字参数 sin_arraynp.savez(&quot;runoob.npz&quot;, a, b, sin_array &#x3D; c)r &#x3D; np.load(&quot;runoob.npz&quot;)  print(r.files) # 查看各个数组名称#  [&#39;sin_array&#39;, &#39;arr_0&#39;, &#39;arr_1&#39;]print(r[&quot;arr_0&quot;]) # 数组 a&quot;&quot;&quot;[[1 2 3] [4 5 6]]&quot;&quot;&quot;print(r[&quot;arr_1&quot;]) # 数组 bprint(r[&quot;sin_array&quot;]) # 数组 c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> -Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习记录</title>
      <link href="/2020/08/03/numpy-xue-xi-ji-lu/"/>
      <url>/2020/08/03/numpy-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<hr><p>Numpy基本使用方法</p><a id="more"></a><h1><span id="一号标题1">一号标题1</span></h1><h2><span id="二号标题1">二号标题1</span></h2><p>​    鲁镇的酒店的格局，是和别处不同的：都是当街一个曲尺形的大柜台，柜里面预备着热水，可以随时温酒。做工的人，傍午傍晚散了工，每每花四文铜钱，买一碗酒，——这是二十多年前的事，现在每碗要涨到十文，——靠柜外站着，热热的喝了休息；倘肯多花一文，便可以买一碟盐煮笋，或者茴香豆，做下酒物了，如果出到十几文，那就能买一样荤菜，但这些顾客，多是短衣帮⑴，大抵没有这样阔绰⑵。只有穿长衫的，才踱进店面隔壁的房子里，要酒要菜，慢慢地坐喝。</p><p>​    我从十二岁起，便在镇口的咸亨酒店里当伙计，掌柜说，样子太傻，怕侍候不了长衫主顾，就在外面做点事罢。外面的短衣主顾，虽然容易说话，但唠唠叨叨缠夹不清的也很不少。他们往往要亲眼看着黄酒从坛子里舀出，看过壶子底里有水没有，又亲看将壶子放在热水里，然后放心：在这严重监督下，羼⑶水也很为难。所以过了几天，掌柜又说我干不了这事。幸亏荐头⑷的情面大，辞退不得，便改为专管温酒的一种无聊职务了。<br>　我从此便整天的站在柜台里，专管我的职务。虽然没有什么失职，但总觉得有些单调，有些无聊。掌柜是一副凶脸孔，主顾也没有好声气⑸，教人活泼不得；只有孔乙己到店，才可以笑几声，所以至今还记得。<br>　孔乙己是站着喝酒而穿长衫的唯一的人。他身材很高大；青白脸色，皱纹间时常夹些伤痕；一部乱蓬蓬的花白的胡子。穿的虽然是长衫，可是又脏又破，似乎十多年没有补，也没有洗。他对人说话，总是满口之乎者也⑹，教人半懂不懂的。因为他姓孔，别人便从描红纸上的“上大人孔乙己⑺”这半懂不懂的话里，替他取下一个绰号，叫作孔乙己。孔乙己一到店，所有喝酒的人便都看着他笑，有的叫道，“孔乙己，你脸上又添上新伤疤了！”他不回答，对柜里说，“温两碗酒，要一碟茴香豆。”便排出九文大钱。他们又故意的高声嚷道，“你一定又偷了人家的东西了！”孔乙己睁大眼睛说，“你怎么这样凭空污人清白……”“什么清白？我前天亲眼见你偷了何家的书，吊着打。”孔乙己便涨红了脸，额上的青筋条条绽出，争辩道，“窃书不能算偷……窃书！……读书人的事，能算偷么？”接连便是难懂的话，什么“君子固穷⑻”，什么“者乎”之类，引得众人都哄笑起来：店内外充满了快活的空气。<br>　听人家背地里谈论，孔乙己原来也读过书，但终于没有进学⑼，又不会营生⑽；于是愈过愈穷，弄到将要讨饭了。幸而写得一笔好字，便替人家钞⑾钞书，换一碗饭吃。可惜他又有一样坏脾气，便是好喝懒做。坐不到几天，便连人和书籍纸张笔砚，一齐失踪。如是几次，叫他抄书的人也没有了。孔乙己没有法，便免不了偶然做些偷窃的事。但他在我们店里，品行却比别人都好，就是从不拖欠；虽然间或没有现钱，暂时记在粉板上，但不出一月，定然还清，从粉板上拭去了孔乙己的名字。　</p><p>一九一九年三月。</p><h2><span id="二号标题2">二号标题2</span></h2><p><img src="/2020/08/03/numpy-xue-xi-ji-lu/image-20200803101601547.png"></p><h1><span id="一号标题2">一号标题2</span></h1><p>乙己喝过半碗酒，涨红的脸色渐渐复了原，旁人便又问道，“孔乙己，你当真认识字么？”孔乙己看着问他的人，显出不屑置辩的神气。他们便接着说道，“你怎的连半个秀才也捞不到呢？”孔乙己立刻显出颓唐不安模样，脸上笼上了一层灰色，嘴里说些话；这回可是全是之乎者也之类，一些不懂了。在这时候，众人也都哄笑起来：店内外充满了快活的空气。<br>　在这些时候，我可以附和着笑，掌柜是决不责备的。而且掌柜见了孔乙己，也每每这样问他，引人发笑。孔乙己自己知道不能和他们谈天，便只好向孩子说话。有一回对我说道，“你读过书么？”我略略点一点头。他说，“读过书，……我便考你一考。茴香豆的茴字，怎样写的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。孔乙己等了许久，很恳切的说道，“不能写罢？……我教给你，记着！这些字应该记着。将来做掌柜的时候，写账要用。”我暗想我和掌柜的等级还很远呢，而且我们掌柜也从不将茴香豆上账；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是草头底下一个来回的回字么？”孔乙己显出极高兴的样子，将两个指头的长指甲敲着柜台，点头说，“对呀对呀！……回字有四样写法⑿，你知道么？”我愈不耐烦了，努着嘴走远。孔乙己刚用指甲蘸了酒，想在柜上写字，见我毫不热心，便又叹一口气，显出极惋惜的样子。<br>　有几回，邻居孩子听得笑声，也赶热闹，围住了孔乙己。他便给他们茴香豆吃，一人一颗。孩子吃完豆，仍然不散，眼睛都望着碟子。孔乙己着了慌，伸开五指将碟子罩住，弯腰下去说道，“不多了，我已经不多了。”直起身又看一看豆，自己摇头说，“不多不多！多乎哉？不多也⒀。”于是这一群孩子都在笑声里走散了。<br>　孔乙己是这样的使人快活，可是没有他，别人也便这么过。<br>　有一天，大约是中秋前的两三天，掌柜正在慢慢的结账，取下粉板，忽然说，“孔乙己长久没有来了。还欠十九个钱呢！”我才也觉得他的确长久没有来了。一个喝酒的人说道，“他怎么会来？……他打折了腿了。”掌柜说，“哦！”“他总仍旧是偷。这一回，是自己发昏，竟偷到丁举人家里去了。他家的东西，偷得的么？”“后来怎么样？”“怎么样？先写服辩⒁，后来是打，打了大半夜，再打折了腿。”“后来呢？”“后来打折了腿了。”“打折了怎样呢？”“怎样？……谁晓得？许是死了。”掌柜也不再问，仍然慢慢的算他的账。<br>　中秋之后，秋风是一天凉比一天，看看将近初冬；我整天的靠着火，也须穿上棉袄了。一天的下半天，没有一个顾客，我正合了眼坐着。忽然间听得一个声音，“温一碗酒。”这声音虽然极低，却很耳熟。看时又全没有人。站起来向外一望，那孔乙己便在柜台下对了门槛坐着。他脸上黑而且瘦，已经不成样子；穿一件破夹袄，盘着两腿，下面垫一个蒲包，用草绳在肩上挂住；见了我，又说道，“温一碗酒。”掌柜也伸出头去，一面说，“孔乙己么？你还欠十九个钱呢！”孔乙己很颓唐的仰面答道，“这……下回还清罢。这一回是现钱，酒要好。”掌柜仍然同平常一样，笑着对他说，“孔乙己，你又偷了东西了！”但他这回却不十分分辩，单说了一句“不要取笑！”“取笑？要是不偷，怎么会打断腿？”孔乙己低声说道，“跌断，跌，跌……”他的眼色，很像恳求掌柜，不要再提。此时已经聚集了几个人，便和掌柜都笑了。我温了酒，端出去，放在门槛上。他从破衣袋里摸出四文大钱，放在我手里，见他满手是泥，原来他便用这手走来的。不一会，他喝完酒，便又在旁人的说笑声中，坐着用这手慢慢走去了。<br>　自此以后，又长久没有看见孔乙己。到了年关⒂，掌柜取下粉板说，“孔乙己还欠十九个钱呢！”到第二年的端午，又说“孔乙己还欠十九个钱呢！”到中秋可是没有说，再到年关也没有看见他。</p><p>​    我到现在终于没有见——大约孔乙己的确死了。 [2] </p><h2><span id="二号标题3">二号标题3</span></h2><p>​    中秋之后，秋风是一天凉比一天，看看将近初冬；我整天的靠着火，也须穿上棉袄了。一天的下半天，没有一个顾客，我正合了眼坐着。忽然间听得一个声音，“温一碗酒。”这声音虽然极低，却很耳熟。看时又全没有人。站起来向外一望，那孔乙己便在柜台下对了门槛坐着。他脸上黑而且瘦，已经不成样子；穿一件破夹袄，盘着两腿，下面垫一个蒲包，用草绳在肩上挂住；见了我，又说道，“温一碗酒。”掌柜也伸出头去，一面说，“孔乙己么？你还欠十九个钱呢！”孔乙己很颓唐的仰面答道，“这……下回还清罢。这一回是现钱，酒要好。”掌柜仍然同平常一样，笑着对他说，“孔乙己，你又偷了东西了！”但他这回却不十分分辩，单说了一句“不要取笑！”“取笑？要是不偷，怎么会打断腿？”孔乙己低声说道，“跌断，跌，跌……”他的眼色，很像恳求掌柜，不要再提。此时已经聚集了几个人，便和掌柜都笑了。我温了酒，端出去，放在门槛上。他从破衣袋里摸出四文大钱，放在我手里，见他满手是泥，原来他便用这手走来的。不一会，他喝完酒，便又在旁人的说笑声中，坐着用这手慢慢走去了。<br>　自此以后，又长久没有看见孔乙己。到了年关⒂，掌柜取下粉板说，“孔乙己还欠十九个钱呢！”到第二年的端午，又说“孔乙己还欠十九个钱呢！”到中秋可是没有说，再到年关也没有看见他。</p>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMD，CMD 规范详解</title>
      <link href="/2017/03/20/amd-cmd/"/>
      <url>/2017/03/20/amd-cmd/</url>
      
        <content type="html"><![CDATA[<p>当我们了解了 <a href="https://neveryu.github.io/2017/03/07/commonjs/">CommonJS</a> 以后，<code>CommonJS</code> 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<br>由于 <code>Node.js</code> 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 <code>CommonJS</code> 规范比较适用。<br>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？</p><a id="more"></a><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'math'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>math<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二行 <code>math.add(2, 3)</code>，在第一行 <code>require(&#39;math&#39;)</code> 之后运行，因此必须等 <code>math.js</code> 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>对于浏览器，这是一个大问题，因为模块都放在服务器端。等待时间取决于网速的快慢，可能要等很长时间，浏览器处理“假死”状态。</p><p>因此，浏览器端的模块，不能采用“同步加载”，只能采用“异步加载”。</p><h1><span id="amd">AMD</span></h1><p><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD 规范</a> 则是异步加载模块，允许指定回调函数。因此浏览器端一般采用 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD 规范</a>。<br><code>AMD(Asynchronous module definition)</code>： <span id="inline-green">异步模块定义。</span></p><p>类似的还有 <code>CommonJS Modules/2.0</code> 规范，是 <code>BravoJS</code> 在推广过程中对模块定义的规范化产出。<br><code>CMD(Common module definition)</code>：<span id="inline-blue">通用模块定义。</span></p><p>目前这些规范的实现都能达成<strong>浏览器端模块化开发的目的</strong>。</p><table><thead><tr><th align="center">服务端JS</th><th align="center">浏览器端JS</th></tr></thead><tbody><tr><td align="center">相同的代码需要多次执行</td><td align="center">代码需要从一个服务器端分发到多个客户端执行</td></tr><tr><td align="center">CPU 和内存资源是瓶颈</td><td align="center">宽带是瓶颈</td></tr><tr><td align="center">加载时从磁盘中加载</td><td align="center">加载时需要通过网络加载</td></tr></tbody></table><p>AMD 的诞生，就是为了解决这两个问题：<br>1.实现 js 文件的异步加载，避免网页失去响应<br>2.管理模块之间的依赖性，便于代码的编写和维护</p><p>AMD(异步模块定义)主要为前端 JS 的表现指定规范。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>AMD 也采用 <a href="https://github.com/amdjs/amdjs-api/wiki/require">require()</a> 语句加载模块，但是不同于 CommonJS，它要求两个参数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span>module<span class="token punctuation">]</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'math'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">math</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  math<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实现 AMD 规范的加载器其实是挺多的，目前，主要有两个 Javascript 库实现了 AMD 规范：<a href="https://github.com/requirejs/requirejs">require.js</a> 和 <a href="https://github.com/cujojs/curl">curl.js</a>。不过多数人还是用 require.js 。<br>另外如果对 ES6 的模块感兴趣，可以考虑 <a href="http://github.com/hax/my.js">my.js</a> ，是按照 ES6 草案的 module/loader 规范实现的。</p><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a> 是 <a href="https://github.com/requirejs/requirejs">require.js</a> 在推广过程中对模块定义的规范化产出。</p><p>推荐学习 <a href="http://requirejs.org/">require.js</a>。</p><h2><span id="amd-模块的写法">AMD 模块的写法</span></h2><p><a href="https://github.com/requirejs/requirejs">require.js</a> 加载的模块，采用 AMD 规范。也就是说，模块必须按照 AMD 的规定来写。<br>具体来说，就是模块必须采用特定的 define() 函数来定义。如果一个模块不依赖其他模块。那么可以直接定义在 define() 函数之中。<br>假定现在有一个 math.js 文件，它定义了一个 math 模块。那么，math.js 就要这样写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// math.js</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　<span class="token keyword">var</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　　<span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span>　<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>　<span class="token keyword">return</span> <span class="token punctuation">&#123;</span>　　add<span class="token operator">:</span> add　<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加载方法如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// main.js</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'math'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">math</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">　alert</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果这个模块还依赖其他模块，那么 define() 函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'myLib'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">myLib</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　　myLib<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　<span class="token punctuation">&#125;</span>　<span class="token keyword">return</span> <span class="token punctuation">&#123;</span>　　foo <span class="token operator">:</span> foo　<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 require() 函数加载上面这个模块的时候，就会先加载 myLib.js 文件。</p><h2><span id="加载非规范的模块">加载非规范的模块</span></h2><p>理论上，<a href="https://github.com/requirejs/requirejs">require.js</a> 加载的模块，必须是按照 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD 规范</a>、用 define() 函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如 jQuery ）符合 AMD 规范，更多的库并不符合。那么，require.js 是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用 require() 加载之前，要先用 require.config() 方法，定义它们的一些特征。<br>举例来说，underscore 和 backbone 这两个库，都没有采用 AMD 规范编写。如果要加载它们的话，必须先定义它们的特征。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">require<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>　shim<span class="token operator">:</span> <span class="token punctuation">&#123;</span>　　<span class="token string">'underscore'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>　　　exports<span class="token operator">:</span> <span class="token string">'_'</span>　　<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>　　<span class="token string">'backbone'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>　　　deps<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'underscore'</span><span class="token punctuation">,</span> <span class="token string">'jquery'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>　　　exports<span class="token operator">:</span> <span class="token string">'Backbone'</span>　　<span class="token punctuation">&#125;</span>　<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>require.config() 接受一个配置对象，这个对象除了有前面说过的 paths 属性之外，还有一个 shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义：<br>（1）exports 值（输出的变量名），表明这个模块外部调用时的名称；<br>（2）deps 数组，表明该模块的依赖性。<br>比如，jQuery 的插件可以这样定义：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">shim<span class="token operator">:</span> <span class="token punctuation">&#123;</span>　<span class="token string">'jquery.scroll'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>　　deps<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'jquery'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>　　exports<span class="token operator">:</span> <span class="token string">'jQuery.fn.scroll'</span>　<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="cmd">CMD</span></h1><p><a href="https://github.com/seajs/seajs/issues/277">CMD</a> 是 <a href="https://github.com/seajs/seajs">sea.js</a> 在推广过程中对模块定义的规范化产出。</p><h3><span id="cmd-模块定义">CMD 模块定义</span></h3><p>在 CMD 规范中，一个模块就是一个文件。define 是一个全局函数，用来定义模块。<br>define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。<br>factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以定义一个 JSON 数据模块：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"foo"</span><span class="token operator">:</span> <span class="token string">"bar"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以通过字符串定义模板模块：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'I am a template.My name is &#123;&#123;name&#125;&#125;.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<br>factory 是一个函数，有三个参数，function(require, exports, module)<br>1、require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)<br>2、exports 是一个对象，用来向外提供模块接口<br>3、module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 依赖就近书写，什么时候用到什么时候引入</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建议写一写 SeaJS 的 CMD 规范，与 AMD 非常类似，在国内的影响力非常大，但是个人觉得 SeaJS 比 RequireJS 好很多，另外由于是国人开发的，交流也非常方便，可以看到 github 上的更新、互动非常频繁。</p><h1><span id="amd-与-cmd-的区别">AMD 与 CMD 的区别</span></h1><p>区别：</p><ol><li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li><li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
